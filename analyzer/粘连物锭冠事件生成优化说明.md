# 粘连物/锭冠异常事件生成逻辑优化说明

**日期**: 2025-10-11  
**修改人**: GitHub Copilot  
**涉及文件**:

- `ai-processor/analyzer/anomaly_event_generator.py`
- `ai-processor/analyzer/video_processor.py`

---

## 一、需求概述

### 1.1 粘连物事件调整

1. **粘连物形成事件**：取前3秒作为异常事件（不足3秒取全部）
2. **粘连物脱落事件**：取后3秒作为异常事件（不足3秒取全部）
3. **脱落位置判断**：
   - 使用 OpenCV 连通域分析判断是否与电极断开连接
   - 如果四周都是熔池（与电极断开），判定为"落入熔池"
   - 如果粘连物存在前最后一帧的前10帧无明显运动（累计运动距离<100像素），且10帧均不在熔池中，判定为"被结晶器捕获"

### 1.2 锭冠事件调整

1. **锭冠脱落事件**：取后3秒作为异常事件（不足3秒取全部）
2. **脱落位置**：固定为"落入熔池"（不需要判断结晶器捕获）

### 1.3 事件类型保持不变

- `ADHESION_FORMED` - 粘连物形成
- `ADHESION_DROPPED` - 粘连物脱落
- `CROWN_DROPPED` - 锭冠脱落

---

## 二、核心技术方案

### 2.1 连通域分析判断脱落位置

**原理**：粘连物在粘连状态下，部分与中间暗色的电极连接在一起。如果与电极断开连接，说明已经漂浮在熔池中。

**实现步骤**：

1. 将图像转为灰度图并高斯模糊去噪
2. 使用 Otsu 自适应阈值进行二值化（暗色=电极，亮色=熔池）
3. 形态学闭运算连接断裂的暗色区域
4. 使用 `cv2.connectedComponentsWithStats` 找连通域
5. 定位图像中心区域的电极连通域
6. 检查粘连物 bbox 区域是否与电极连通域有交集
7. 无交集 → 已脱离电极 → 在熔池中

**关键代码**：

```python
def _is_surrounded_by_pool(self, frame, bbox, frame_number):
    # 1. 图像预处理
    gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
    blurred = cv2.GaussianBlur(gray, (5, 5), 0)
    
    # 2. 二值化并反转
    _, binary = cv2.threshold(blurred, 0, 255, cv2.THRESH_BINARY + cv2.THRESH_OTSU)
    binary_inv = cv2.bitwise_not(binary)
    
    # 3. 形态学闭运算
    kernel = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (5, 5))
    closed = cv2.morphologyEx(binary_inv, cv2.MORPH_CLOSE, kernel)
    
    # 4. 连通域分析
    num_labels, labels, stats, centroids = cv2.connectedComponentsWithStats(closed, connectivity=8)
    
    # 5. 找电极区域
    center_x, center_y = w // 2, h // 2
    electrode_label = labels[center_y, center_x]
    
    # 6. 检查 bbox 是否与电极连接
    bbox_region = labels[y1:y2, x1:x2]
    has_electrode = np.any(bbox_region == electrode_label)
    
    return not has_electrode  # 无交集 = 已脱离
```

### 2.2 运动距离计算

**目的**：判断粘连物是否被结晶器捕获（静止或微动）

**实现**：

```python
def _calculate_trajectory_movement(self, trajectory):
    total_distance = 0.0
    for i in range(1, len(trajectory)):
        prev_center = self._get_bbox_center(trajectory[i-1]['bbox'])
        curr_center = self._get_bbox_center(trajectory[i]['bbox'])
        
        dx = curr_center[0] - prev_center[0]
        dy = curr_center[1] - prev_center[1]
        distance = np.sqrt(dx**2 + dy**2)
        
        total_distance += distance
    
    return total_distance
```

### 2.3 帧读取与缓存

**优化**：避免重复读取同一帧，提高性能

**实现**：

```python
def _read_frame(self, frame_number):
    # 检查缓存
    if frame_number in self.frame_cache:
        return self.frame_cache[frame_number]
    
    # 延迟初始化 VideoCapture
    if self.video_cap is None:
        self.video_cap = cv2.VideoCapture(self.video_path)
    
    # 读取帧
    self.video_cap.set(cv2.CAP_PROP_POS_FRAMES, frame_number)
    ret, frame = self.video_cap.read()
    
    # 缓存帧（最多100帧）
    if ret and len(self.frame_cache) < 100:
        self.frame_cache[frame_number] = frame
    
    return frame if ret else None
```

---

## 三、详细修改内容

### 3.1 anomaly_event_generator.py

#### 3.1.1 新增/修改的属性

```python
def __init__(self, fps=30.0, video_path=None):
    self.fps = fps
    self.time_window_frames = int(5 * fps)      # 5秒（其他事件）
    self.event_window_frames = int(3 * fps)     # 3秒（粘连物/锭冠）
    self.video_path = video_path                # 视频路径
    self.frame_cache = {}                       # 帧缓存
    self.video_cap = None                       # VideoCapture对象
```

#### 3.1.2 重构的 generate_events 方法

**主要变更**：

- 对粘连物和锭冠采用独立的事件生成逻辑
- 为每个粘连物生成形成和脱落两个事件
- 为每个锭冠生成脱落事件
- 其他类别保持原有逻辑（取最早/最晚物体）

```python
if category == 'ADHESION':
    for obj in objects:
        adhesion_events = self._generate_adhesion_events(obj, video_perspective)
        events.extend(adhesion_events)

elif category == 'CROWN':
    for obj in objects:
        crown_events = self._generate_crown_events(obj)
        events.extend(crown_events)
```

#### 3.1.3 新增方法

**`_generate_adhesion_events(adhesion_obj, video_perspective)`**

- 生成粘连物形成事件：`firstFrame` → `min(firstFrame + 3秒, lastFrame)`
- 生成粘连物脱落事件：`max(lastFrame - 3秒, firstFrame)` → `lastFrame`
- 调用 `_analyze_adhesion_drop` 判断脱落位置

**`_generate_crown_events(crown_obj)`**

- 生成锭冠脱落事件：`max(lastFrame - 3秒, firstFrame)` → `lastFrame`
- 脱落位置固定为 `'pool'`

**`_is_surrounded_by_pool(frame, bbox, frame_number)`**

- 使用连通域分析判断物体是否与电极断开连接
- 返回 `True`（在熔池中）或 `False`（仍与电极连接）

**`_calculate_trajectory_movement(trajectory)`**

- 计算轨迹的累计欧氏距离
- 返回总移动像素数

**`_read_frame(frame_number)`**

- 从视频读取指定帧（带缓存）
- 限制缓存最多100帧

**`_cleanup()`**

- 释放 VideoCapture 资源
- 清空帧缓存

#### 3.1.4 重构的 _analyze_adhesion_drop 方法

**判断逻辑优先级**：

1. **优先级1**：检查最后一帧是否被熔池包围 → `'pool'`
2. **优先级2**：检查前10帧运动距离<100px 且均不在熔池中 → `'crystallizer'`
3. **优先级3**：使用原有方向判断（fallback）
4. **默认**：`'pool'`

```python
# 策略1: 连通域分析
frame = self._read_frame(last_frame_num)
if self._is_surrounded_by_pool(frame, last_bbox, last_frame_num):
    return 'pool'

# 策略2: 结晶器捕获判断
if len(trajectory) >= 10:
    check_trajectory = trajectory[-10:]
    movement_distance = self._calculate_trajectory_movement(check_trajectory)
    all_not_in_pool = True
    for traj_point in check_trajectory:
        if self._is_surrounded_by_pool(...):
            all_not_in_pool = False
            break
    
    if movement_distance < 100 and all_not_in_pool:
        return 'crystallizer'

# 策略3: 方向判断
return self._determine_drop_location(trajectory, video_perspective)
```

### 3.2 video_processor.py

#### 修改点

在创建 `AnomalyEventGenerator` 时传递 `video_path` 参数：

```python
# 修改前
anomaly_generator = AnomalyEventGenerator(fps=fps)

# 修改后
anomaly_generator = AnomalyEventGenerator(fps=fps, video_path=final_video_path)
```

---

## 四、事件生成示例

### 4.1 粘连物事件

**假设**：

- 粘连物出现：第100帧
- 粘连物消失：第400帧
- FPS：30
- 3秒 = 90帧

**生成事件**：

1. **粘连物形成事件**

   ```json
   {
     "eventType": "ADHESION_FORMED",
     "startFrame": 100,
     "endFrame": 190,  // min(100 + 90, 400)
     "objectId": null,
     "metadata": null
   }
   ```

2. **粘连物脱落事件**

   ```json
   {
     "eventType": "ADHESION_DROPPED",
     "startFrame": 310,  // max(400 - 90, 100)
     "endFrame": 400,
     "objectId": null,
     "metadata": {
       "dropped_location": "pool"  // 或 "crystallizer"
     }
   }
   ```

### 4.2 锭冠事件

**假设**：

- 锭冠出现：第200帧
- 锭冠消失：第250帧
- 3秒 = 90帧，但持续时间<3秒

**生成事件**：

```json
{
  "eventType": "CROWN_DROPPED",
  "startFrame": 200,  // max(250 - 90, 200) = 200
  "endFrame": 250,
  "objectId": null,
  "metadata": {
    "dropped_location": "pool"  // 固定为熔池
  }
}
```

---

## 五、关键参数

### 5.1 可调参数

| 参数 | 默认值 | 说明 |
|------|--------|------|
| `event_window_frames` | 90帧（3秒@30fps） | 粘连物/锭冠事件时间窗口 |
| 形态学核大小 | (5, 5) | 连通域分析的闭运算核 |
| 运动距离阈值 | 100像素 | 判断是否被结晶器捕获 |
| 检查帧数 | 10帧 | 结晶器捕获判断的回溯帧数 |
| 帧缓存上限 | 100帧 | 避免内存溢出 |

### 5.2 建议调优方向

1. **二值化阈值**：当前使用 Otsu 自适应，可根据实际情况改为固定阈值
2. **形态学核大小**：影响连通域的连接程度，可调整为 (3,3) 或 (7,7)
3. **运动距离阈值**：可根据实际视频分辨率调整（100像素适合1920x1080）
4. **检查帧数**：可调整为5帧或15帧

---

## 六、测试建议

### 6.1 测试场景

1. ✅ **粘连物刚形成**：部分与电极连接
2. ✅ **粘连物拉长变形**：细微连接
3. ✅ **粘连物完全脱离**：在熔池中漂浮
4. ✅ **粘连物被结晶器捕获**：静止或微动
5. ✅ **强光电弧干扰**：影响二值化效果
6. ✅ **多个粘连物同时存在**
7. ✅ **锭冠脱落**

### 6.2 验证方法

1. 检查日志中的 `Object is SEPARATED/CONNECTED` 输出
2. 查看 `movement_distance` 是否符合预期
3. 验证事件的 `startFrame` 和 `endFrame` 是否正确
4. 检查 `dropped_location` 是否准确

---

## 七、注意事项

1. **视频路径必须传递**：否则无法读取帧进行连通域分析
2. **资源释放**：`_cleanup()` 方法会在 `generate_events` 结束时自动调用
3. **帧缓存限制**：最多缓存100帧，避免内存溢出
4. **日志级别**：连通域分析使用 `DEBUG` 级别，可根据需要调整
5. **异常处理**：连通域分析失败时会返回 `False`（默认认为仍与电极连接）

---

## 八、性能优化

1. **延迟初始化**：VideoCapture 仅在第一次读取帧时初始化
2. **帧缓存**：避免重复读取同一帧
3. **选择性读取**：仅读取需要分析的关键帧（最后一帧、前10帧）
4. **及时释放**：事件生成完成后立即释放视频资源

---

## 九、后续优化方向

1. **自适应阈值调整**：根据视频整体亮度动态调整二值化阈值
2. **机器学习分类器**：训练分类器替代规则判断，提高准确率
3. **多帧融合**：综合多帧的连通域结果，减少单帧噪声影响
4. **GPU加速**：使用 `cv2.cuda` 加速图像处理（如果可用）

---

**修改完成时间**: 2025-10-11  
**测试状态**: ✅ 语法检查通过，待实际数据验证
